#pragma once

			//int += float;
#define OPCODE_OPERATOR2(T1, T2, OPERATOR)\
CODEGET(OFFSET_T, R1);\
CODEGET(OFFSET_T, R2);\
*REGISTER(T1, CODE(R1)) OPERATOR *REGISTER(T1, CODE(R2))

			//int = int / float;
#define OPCODE_OPERATOR3(T1, T2, TR, OPERATOR)\
CODEGET(OFFSET_T, R1);\
CODEGET(OFFSET_T, R2);\
*REGISTER(TR, CODE(R1)) = *REGISTER(T1, CODE(R1)) OPERATOR *REGISTER(T2, CODE(R2))

			//int += int;
#define OPCODE_ST_OPERATOR2(T, OPERATOR)\
CODEGET(OFFSET_T, R1);\
CODEGET(OFFSET_T, R2);\
*REGISTER(T, CODE(R1)) OPERATOR *REGISTER(T, CODE(R2))

			//int = int / int;
#define OPCODE_ST_OPERATOR3(T, OPERATOR)\
CODEGET(OFFSET_T, R1);\
CODEGET(OFFSET_T, R2);\
*REGISTER(T, CODE(R1)) = *REGISTER(T, CODE(R1)) OPERATOR *REGISTER(T, CODE(R2))

#define OPCODE_PUSH(T)\
CODEGET(OFFSET_T, R1);\
CODEGET(T, P_VALUE);\
*REGISTER(T, CODE(R1)) = CODE(P_VALUE);

//int = float
#define OPCODE_CAST(T1, T2)\
CODEGET(OFFSET_T, R1);\
CODEGET(OFFSET_T, R2);\
*REGISTER(T1, CODE(R1)) = *REGISTER(T2, CODE(R2))

#define CASE_OPERATOR2(T1, T2, OPERATOR, NAME)\
case LsAsm::##NAME##_##T1##_T2: { OPCODE_OPERATOR2(T1, T2, OPERATOR); break; }

#define CASE_OPERATOR3(T1, T2, TR, OPERATOR, NAME)\
case LsAsm::##NAME##_##T1##_T2##_##TR: { OPCODE_OPERATOR3(T1, T2, TR, OPERATOR); break; }

#define CASE_ST_OPERATOR2(T, OPERATOR, NAME)\
case LsAsm::##NAME##_##T: { OPCODE_ST_OPERATOR2(T, OPERATOR); break; }

#define CASE_ST_OPERATOR3(T, OPERATOR, NAME)\
case LsAsm::##NAME##_##T: { OPCODE_ST_OPERATOR3(T, OPERATOR); break; }

#define MULTICASE_ST_ARITHMETICS(T)\
CASE_ST_OPERATOR3(T, +, add)\
CASE_ST_OPERATOR3(T, -, sub)\
CASE_ST_OPERATOR3(T, *, mul)\
CASE_ST_OPERATOR3(T, /, div)\

#define CASE_CAST(T1, T2)\
case LsAsm::cast_##T1##_##T2: { OPCODE_CAST(T1, T2); break; } 

#define CASE_PUSH(T)\
case LsAsm::push_##T: { OPCODE_PUSH(T); break; }

#define CASE_CUSTOM(name, ...)\
case LsAsm::name: { __VA_ARGS__; break; };